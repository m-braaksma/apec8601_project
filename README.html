<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="earth-economy-modeling-for-apec-8601-natural-resource-economics" class="level1">
<h1>Earth Economy Modeling for APEC 8601: Natural Resource Economics</h1>
<section id="country-ghana" class="level4">
<h4 class="anchored" data-anchor-id="country-ghana">Country: Ghana</h4>
</section>
<section id="scenarios-ssp1-rcp2.6-ssp2-rcp4.5-ssp5-rcp8.5" class="level4">
<h4 class="anchored" data-anchor-id="scenarios-ssp1-rcp2.6-ssp2-rcp4.5-ssp5-rcp8.5">Scenarios: SSP1-RCP2.6, SSP2-RCP4.5, SSP5-RCP8.5</h4>
</section>
<section id="policy-prevent-expansion-of-cropland-into-forest" class="level4">
<h4 class="anchored" data-anchor-id="policy-prevent-expansion-of-cropland-into-forest">Policy: Prevent expansion of cropland into forest</h4>
</section>
<section id="seals" class="level2">
<h2 class="anchored" data-anchor-id="seals">SEALS</h2>
<p>Use the Spatial Economic Allocation Landscape Simulator (SEALS) to model land-use change and generate LULC maps for 2030, 2035, and 2040 under different Shared Socioeconomic Pathway (SSP) and Representative Concentration Pathways (RCP) scenarios.</p>
<section id="scenarios" class="level3">
<h3 class="anchored" data-anchor-id="scenarios">Scenarios</h3>
<ul>
<li>Scenario 1:
<ul>
<li>SSP1: Sustainability – Taking the Green Road (Low challenges to mitigation and adaptation)</li>
<li>RCP2.6: Least amount of climate forcing</li>
</ul></li>
<li>Scenario 2:
<ul>
<li>SSP2: Middle of the Road (Medium challenges to mitigation and adaptation)</li>
<li>RCP4.6: Low amount of climate forcing</li>
</ul></li>
<li>Scenario 3:
<ul>
<li>SSP5: Fossil-fueled Development – Taking the Highway (High challenges to mitigation, low challenges to adaptation)</li>
<li>RCP8.5: Highest amount of climate forcing</li>
</ul></li>
</ul>
<p><img src="plots/ghana_standard.png" class="img-fluid"></p>
<section id="description" class="level5">
<h5 class="anchored" data-anchor-id="description">Description</h5>
<p>From the plots, we can see how different Ghana’s landscape may look depending on the given scenario. In all cases, the urban area appears to expand, reflecting the country’s place as a developing country. However, the largest difference is the decrease in forest and grassland, with large portions remaining in the southwest in SSP1-RCP2.6 and SSP2-RCP4.5, while it has been virtually completely replaced by cropland in SSP5-RCP8.5.</p>
</section>
</section>
<section id="scenarios-under-policy" class="level3">
<h3 class="anchored" data-anchor-id="scenarios-under-policy">Scenarios under Policy</h3>
<p>Suppose Ghana, in an effort to end deforestation, implements a policy that prevents any cropland expansion into forest land.</p>
<p><img src="plots/ghana_policy_forest.png" class="img-fluid"></p>
<section id="description-1" class="level5">
<h5 class="anchored" data-anchor-id="description-1">Description</h5>
<p>Now, we can observe how a strict anti-deforestation policy may change land-use trends under the various scenarios. In stark contrast to the previous maps, SSP5-RCP8.5 no longer exhibits a large decrease in forest. Grassland still appears to encroach into the forest in the central part of the country, but to a much lesser degree. The policy appears to have a much smaller impact in SSP1-RCP2.6 and SSP2-RCP4.5, where deforestation is driving much less of the land-use change.</p>
</section>
</section>
</section>
<section id="invest" class="level2">
<h2 class="anchored" data-anchor-id="invest">InVEST</h2>
<p>Based on the LULC maps generated by SEALS under the policy, use InVEST to forecast ecosystem service provision for carbon storage, annual water yield, pollination, sediment retention, and nutrient retention.</p>
<section id="carbon-storage" class="level3">
<h3 class="anchored" data-anchor-id="carbon-storage">Carbon Storage</h3>
<p><img src="plots/carbon.png" class="img-fluid"></p>
</section>
<section id="annual-water-yield" class="level3">
<h3 class="anchored" data-anchor-id="annual-water-yield">Annual Water Yield</h3>
<p><img src="plots/annual_water_yield.png" class="img-fluid"></p>
</section>
<section id="pollination" class="level3">
<h3 class="anchored" data-anchor-id="pollination">Pollination</h3>
<p><img src="plots/pollination.png" class="img-fluid"></p>
</section>
<section id="sediment-retention" class="level3">
<h3 class="anchored" data-anchor-id="sediment-retention">Sediment Retention</h3>
<p><img src="plots/sediment_delivery.png" class="img-fluid"></p>
</section>
<section id="nutrient-retention" class="level3">
<h3 class="anchored" data-anchor-id="nutrient-retention">Nutrient Retention</h3>
<p><img src="plots/nutrient_delivery.png" class="img-fluid"></p>
<section id="description-2" class="level5">
<h5 class="anchored" data-anchor-id="description-2">Description</h5>
<p>Since the policy is effective at preventing primary areas of deforestation in SSP5-RCP8.5, the ecosystem service provision is relatively consistent across the scenarios. There may be small areas of gains, but at the country level, it appears that preventing cropland expansion into forested areas is key to maintaining a consistent level of ecosystem service provision, even under more dire scenarios. The provision is also fairly consistent across the ecosystem services, which indicates that forests are a key driver of the value of ecosystem services.</p>
</section>
</section>
</section>
<section id="executive-summary" class="level2">
<h2 class="anchored" data-anchor-id="executive-summary">Executive Summary</h2>
<p>Summary</p>
</section>
<section id="technical-details" class="level2">
<h2 class="anchored" data-anchor-id="technical-details">Technical Details</h2>
<section id="setup" class="level3">
<h3 class="anchored" data-anchor-id="setup">Setup</h3>
<p>This project requires a proper installation of the earth_economy_devstack and associated project directory and data directory. Visit the <a href="https://github.com/jandrewjohnson/seals">SEALS repository</a> for more information.</p>
</section>
<section id="basic-outline" class="level3">
<h3 class="anchored" data-anchor-id="basic-outline">Basic Outline</h3>
<ol type="1">
<li><p>Baseline SEALS</p>
<p>For a new standard SEALS run, several modifications must be made. <code>scenario_definitions.csv</code> must be updated to reflect the desired years, AOI (iso3 country code), SSP-RCP scenarios (<a href="https://luh.umd.edu/data.shtml">Land Use Harmonization data</a>). Create a new project folder and change <code>project_name = 'country_standard'</code> in <code>run_test_standard.py</code>.</p>
<ul>
<li><code>run_seals_ghana_standard.py</code></li>
</ul></li>
<li><p>Policy SEALS</p>
<p>To run SEALS with a new policy applied, <code>default_global_coefficients.csv</code> must be updated to reflect how the policy will impact land use change. For example, to prevent cropland expansion into forest, change the multiplicative coefficient <code>forest_constraint=0</code> for <code>cropland</code>. It is also possible to add a new raster layer to effect land use change.</p>
<ul>
<li><code>run_seals_ghana_policy.py</code></li>
</ul></li>
<li><p>InVEST models</p>
<p>The SEALS LULC maps can be used as the primary input to model ecosystem services using InVEST. In addition to LULC data, the models require other global input data for each process based model. The input data may need to processed before running InVEST, including reprojecting and clipping.</p>
<ul>
<li><code>process_invest_inputs.py</code></li>
<li><code>run_invest_ghana_policy.py</code></li>
</ul></li>
<li><p>Visualization</p>
<p>After running SEALS and InVEST, the maps may be visualized to explore the results.</p>
<ul>
<li><code>seals_plot.py</code></li>
<li><code>invest_plot.py</code></li>
</ul></li>
</ol>
</section>
<section id="other-projects" class="level3">
<h3 class="anchored" data-anchor-id="other-projects">Other Projects</h3>
<p>In addition to this project, I developed other code for APEC 8601: Natural Resource Economics.</p>
<ul>
<li><a href="problem_sets/apec8601_mbraak_ps1.html">Problem Set 1</a></li>
<li><a href="problem_sets/problem_set_2_v2_mbraak.ipynb">Problem Set 2</a></li>
<li><a href="problem_sets/apec8601_mbraak_ps3.html">Problem Set 3</a></li>
<li><a href="problem_sets/apec8601_mbraak_ps4.html">Problem Set 4</a></li>
</ul>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>